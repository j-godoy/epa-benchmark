/* Copyright (c) 2001-2010, The HSQL Development Group
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are met:
 *
 * Redistributions of source code must retain the above copyright notice, this
 * list of conditions and the following disclaimer.
 *
 * Redistributions in binary form must reproduce the above copyright notice,
 * this list of conditions and the following disclaimer in the documentation
 * and/or other materials provided with the distribution.
 *
 * Neither the name of the HSQL Development Group nor the names of its
 * contributors may be used to endorse or promote products derived from this
 * software without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
 * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED. IN NO EVENT SHALL HSQL DEVELOPMENT GROUP, HSQLDB.ORG,
 * OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
 * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
 * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
 * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
 * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
 * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */

package com.example.resultset;

//#ifdef JAVA6

//#endif JAVA6

/* $Id: JDBCResultSet.java 3596 2010-05-30 13:06:33Z fredt $ */

//boucherb@users 20051207 - patch 1.9.0 - initial JDBC 4.0 support work
//fredt@users    20060431 - patch 1.9.0 rewrite with RowSetNavigator
//boucherb@users 20060522 - doc   1.9.0 - full synch up to Mustang Build 84
// Revision 1.21  2006/07/12 12:27:25  boucherb
// patch 1.9.0
// - full synch up to Mustang b90

/**
 * <!-- start generic documentation --> A table of data representing a database
 * result set, which is usually generated by executing a statement that queries
 * the database.
 *
 * <P>
 * A <code>ResultSet</code> object maintains a cursor pointing to its current
 * row of data. Initially the cursor is positioned before the first row. The
 * <code>next</code> method moves the cursor to the next row, and because it
 * returns <code>false</code> when there are no more rows in the
 * <code>ResultSet</code> object, it can be used in a <code>while</code> loop to
 * iterate through the result set.
 * <P>
 * A default <code>ResultSet</code> object is not updatable and has a cursor
 * that moves forward only. Thus, you can iterate through it only once and only
 * from the first row to the last row. It is possible to produce
 * <code>ResultSet</code> objects that are scrollable and/or updatable. The
 * following code fragment, in which <code>con</code> is a valid
 * <code>Connection</code> object, illustrates how to make a result set that is
 * scrollable and insensitive to updates by others, and that is updatable. See
 * <code>ResultSet</code> fields for other options.
 * 
 * <PRE>
 *
 * Statement stmt = con.createStatement(ResultSet.TYPE_SCROLL_INSENSITIVE, ResultSet.CONCUR_UPDATABLE);
 * ResultSet rs = stmt.executeQuery("SELECT a, b FROM TABLE2");
 * // rs will be scrollable, will not show changes made by others,
 * // and will be updatable
 *
 * </PRE>
 * 
 * The <code>ResultSet</code> interface provides <i>getter</i> methods
 * (<code>getBoolean</code>, <code>getLong</code>, and so on) for retrieving
 * column values from the current row. Values can be retrieved using either the
 * index number of the column or the name of the column. In general, using the
 * column index will be more efficient. Columns are numbered from 1. For maximum
 * portability, result set columns within each row should be read in
 * left-to-right order, and each column should be read only once.
 *
 * <P>
 * For the getter methods, a JDBC driver attempts to convert the underlying data
 * to the Java type specified in the getter method and returns a suitable Java
 * value. The JDBC specification has a table showing the allowable mappings from
 * SQL types to Java types that can be used by the <code>ResultSet</code> getter
 * methods.
 * <P>
 * <P>
 * Column names used as input to getter methods are case insensitive. When a
 * getter method is called with a column name and several columns have the same
 * name, the value of the first matching column will be returned. The column
 * name option is designed to be used when column names are used in the SQL
 * query that generated the result set. For columns that are NOT explicitly
 * named in the query, it is best to use column numbers. (JDBC4 clarification:)
 * If column names are used, the programmer should take care to guarantee that
 * they uniquely refer to the intended columns, which can be assured with the
 * SQL <i>AS</i> clause.
 * <P>
 * A set of updater methods were added to this interface in the JDBC 2.0 API
 * (Java<sup><font size=-2>TM</font></sup> 2 SDK, Standard Edition, version
 * 1.2). The comments regarding parameters to the getter methods also apply to
 * parameters to the updater methods.
 * <P>
 * The updater methods may be used in two ways:
 * <ol>
 * <li>to update a column value in the current row. In a scrollable
 * <code>ResultSet</code> object, the cursor can be moved backwards and
 * forwards, to an absolute position, or to a position relative to the current
 * row. The following code fragment updates the <code>NAME</code> column in the
 * fifth row of the <code>ResultSet</code> object <code>rs</code> and then uses
 * the method <code>updateRow</code> to update the data source table from which
 * <code>rs</code> was derived.
 * 
 * <PRE>
 *
 * rs.absolute(5); // moves the cursor to the fifth row of rs
 * rs.updateString("NAME", "AINSWORTH"); // updates the
 * // <code>NAME</code> column of row 5 to be <code>AINSWORTH</code>
 * rs.updateRow(); // updates the row in the data source
 *
 * </PRE>
 * 
 * </li>
 * <li>to insert column values into the insert row. An updatable
 * <code>ResultSet</code> object has a special row associated with it that
 * serves as a staging area for building a row to be inserted. The following
 * code fragment moves the cursor to the insert row, builds a three-column row,
 * and inserts it into <code>rs</code> and into the data source table using the
 * method <code>insertRow</code>.
 * 
 * <PRE>
 *
 * rs.moveToInsertRow(); // moves cursor to the insert row
 * rs.updateString(1, "AINSWORTH"); // updates the
 * // first column of the insert row to be <code>AINSWORTH</code>
 * rs.updateInt(2, 35); // updates the second column to be <code>35</code>
 * rs.updateBoolean(3, true); // updates the third column to <code>true</code>
 * rs.insertRow();
 * rs.moveToCurrentRow();
 *
 * </PRE>
 * 
 * </li>
 * </ol>
 * <P>
 * A <code>ResultSet</code> object is automatically closed when the
 * <code>Statement</code> object that generated it is closed, re-executed, or
 * used to retrieve the next result from a sequence of multiple results.
 *
 * <P>
 * The number, types and properties of a <code>ResultSet</code> object's columns
 * are provided by the <code>ResulSetMetaData</code> object returned by the
 * <code>ResultSet.getMetaData</code> method. <!-- end generic documentation -->
 *
 * <!-- start release-specific documentation -->
 * <div class="ReleaseSpecificDocumentation">
 * <h3>HSQLDB-Specific Information:</h3>
 * <p>
 *
 * A <code>ResultSet</code> object generated by HSQLDB is by default of
 * <code>ResultSet.TYPE_FORWARD_ONLY</code> (as is standard JDBC behavior) and
 * does not allow the use of absolute and relative positioning methods. If a
 * statement is created with:
 * <p>
 *
 * <pre class="JavaCodeExample">
 * Statement stmt = conn.<b>createStatement</b>(ResultSet.TYPE_SCROLL_INSENSITIVE, ResultSet.CONCUR_READ_ONLY);
 * </pre>
 *
 * then the <code>ResultSet</code> objects it produces support using all of the
 * absolute and relative positioning methods of JDBC2 to set the position of the
 * current row, for example:
 * <p>
 *
 * <pre class="JavaCodeExample">
 * rs.<b>absolute</b>(<span class="JavaNumericLiteral">5</span>);
 * String fifthRowValue = rs.<b>getString</b>(<span class=
"JavaNumericLiteral">1</span>);
 * rs.<b>relative</b>(<span class="JavaNumericLiteral">4</span>);
 * String ninthRowValue = rs.<b>getString</b>(<span class=
"JavaNumericLiteral">1</span>);
 * </pre>
 *
 * Note: An HSQLDB <code>ResultSet</code> object persists, even after its
 * connection is closed. This is regardless of the operational mode of the
 * {@link com.example.Database Database} from which it came. That is, they
 * persist whether originating from a <code>Server</code>,
 * <code>WebServer</code> or in-process mode <code>Database.</code>
 * <p>
 *
 * From HSQLDB 2.0, there is full support for updatable result sets. Supported
 * methods include all updateXXX methods for the supported types, as well as the
 * {@link #insertRow}, {@link #updateRow}, {@link #deleteRow},
 * {@link #moveToInsertRow} methods.
 * <p>
 *
 * The Statement must be created with ResultSet.CONCUR_UPDATABLE instead of
 * CONCUR_READ_ONLY.
 * <p>
 *
 * Updatability of a result set follows the SQL standards. Some or all columns
 * of an updatable result set can be updated. The current row in such result
 * sets can be deleted using the {@link #deleteRow} method. Some updatable
 * result set can also be inserted into and support {@link #moveToInsertRow}.
 * <p>
 *
 * A result set is updatable if the SELECT statement is updatable. This includes
 * SELECT from TABLE and updatable VIEW objects. An updatable SELECT statement
 * has a single uderlying table or view. HSQLDB supports both scrollable and
 * forward-only result sets for updatability.
 *
 * <pre class="JavaCodeExample">
 * -- In the SELECT below, columns A and B are updatable, any row can be
 * -- deleted, but it is not insertable-into as column C is not directly from
 * -- the table.
 * SELECT A, B, A + B AS C FROM T WHERE ...
 *
 * -- The SELECT below can be insertable-into so long as other columns of the
 * -- table that do not appear in the SELECT list have a default value.
 * SELECT A, B FROM T WHERE ...
 * </pre>
 *
 * <b>JRE 1.1.x Notes:</b>
 * <p>
 *
 * In general, JDBC 2 support requires Java 1.2 and above, and JDBC 3 requires
 * Java 1.4 and above. In HSQLDB, support for methods introduced in different
 * versions of JDBC depends on the JDK version used for compiling and building
 * HSQLDB.
 * <p>
 *
 * Since 1.7.0, it is possible to build the product so that all JDBC 2 methods
 * can be called while executing under the version 1.1.x <em>Java Runtime
 * Environment</em><sup><font size="-2">TM</font></sup>. However, some of these
 * method calls require <code>int</code> values that are defined only in the
 * JDBC 2 or greater version of the {@link MockResultSet ResultSet} interface.
 * For this reason, when the product is compiled under JDK 1.1.x, these values
 * are defined here, in this class.
 * <p>
 *
 * In a JRE 1.1.x environment, calling JDBC 2 methods that take or return the
 * JDBC2-only <code>ResultSet</code> values can be achieved by referring to them
 * in parameter specifications and return value comparisons, respectively, as
 * follows:
 * <p>
 *
 * <pre class="JavaCodeExample">
 * JDBCResultSet.FETCH_FORWARD
 * JDBCResultSet.TYPE_FORWARD_ONLY
 * JDBCResultSet.TYPE_SCROLL_INSENSITIVE
 * JDBCResultSet.CONCUR_READ_ONLY
 * // etc.
 * </pre>
 *
 * However, please note that code written in such a manner will not be
 * compatible for use with other JDBC 2 drivers, since they expect and use
 * <code>ResultSet</code>, rather than <code>JDBCResultSet</code>. Also note,
 * this feature is offered solely as a convenience to developers who must work
 * under JDK 1.1.x due to operating constraints, yet wish to use some of the
 * more advanced features available under the JDBC 2 specification.
 * <p>
 *
 * (fredt@users) <br>
 * (boucherb@users)
 * <p>
 *
 * </div>
 * 
 * @see JDBCStatement#executeQuery
 * @see JDBCStatement#getResultSet
 * @see MockResultSetMetaData
 *
 * @author Campbell Boucher-Burnett (boucherb@users dot sourceforge.net)
 * @author Fred Toussi (fredt@users dot sourceforge.net)
 * @version 2.0
 * @since 1.9.0
 */
public class JDBCResultSet implements MockResultSet {

	/**
	 * <!-- start generic documentation --> Moves the cursor froward one row from
	 * its current position. A <code>ResultSet</code> cursor is initially positioned
	 * before the first row; the first call to the method <code>next</code> makes
	 * the first row the current row; the second call makes the second row the
	 * current row, and so on.
	 * <p>
	 * (JDBC4 clarification:) When a call to the <code>next</code> method returns
	 * <code>false</code>, the cursor is positioned after the last row. Any
	 * invocation of a <code>ResultSet</code> method which requires a current row
	 * will result in a <code>SQLException</code> being thrown. If the result set
	 * type is <code>TYPE_FORWARD_ONLY</code>, it is vendor specified whether their
	 * JDBC driver implementation will return <code>false</code> or throw an
	 * <code>SQLException</code> on a subsequent call to <code>next</code>.
	 *
	 * <P>
	 * If an input stream is open for the current row, a call to the method
	 * <code>next</code> will implicitly close it. A <code>ResultSet</code> object's
	 * warning chain is cleared when a new row is read. <!-- end generic
	 * documentation -->
	 *
	 * @return <code>true</code> if the new current row is valid; <code>false</code>
	 *         if there are no more rows
	 * @exception MockSQLException
	 *                if a database access error occurs or this method is called on
	 *                a closed result set
	 */
	public boolean next() throws MockSQLException, Exception {
		try {
			boolean rv = next0();
			return rv;
		} catch (Exception ex) {
			throw ex;
		}

	}

	private boolean next0() throws MockSQLException, Exception {

		checkClosed();

		rootWarning = null;

		return navigator.next();
	}

	/**
	 * <!-- start generic documentation --> Releases this <code>ResultSet</code>
	 * object's database and JDBC resources immediately instead of waiting for this
	 * to happen when it is automatically closed.
	 *
	 * <P>
	 * (JDBC4 clarification:) The closing of a <code>ResultSet</code> object does
	 * <strong>not</strong> close the <code>Blob</code>, <code>Clob</code> or
	 * <code>NClob</code> objects created by the <code>ResultSet</code>.
	 * <code>Blob</code>, <code>Clob</code> or <code>NClob</code> objects remain
	 * valid for at least the duration of the transaction in which they are created,
	 * unless their <code>free</code> method is invoked.
	 * <p>
	 * (JDBC4 clarification:) When a <code>ResultSet</code> is closed, any
	 * <code>ResultSetMetaData</code> instances that were created by calling the
	 * <code>getMetaData</code> method remain accessible.
	 *
	 * <P>
	 * <B>Note:</B> A <code>ResultSet</code> object is automatically closed by the
	 * <code>Statement</code> object that generated it when that
	 * <code>Statement</code> object is closed, re-executed, or is used to retrieve
	 * the next result from a sequence of multiple results. (JDBC4 deleted:) [A
	 * <code>ResultSet</code> object is also automatically closed when it is garbage
	 * collected.]
	 * <p>
	 * Calling the method <code>close</code> on a <code>ResultSet</code> object that
	 * is already closed is a no-op.
	 * <P>
	 * <p>
	 * <!-- end generic documentation -->
	 *
	 * @exception MockSQLException
	 *                if a database access error occurs
	 */
	public void close() throws MockSQLException, Exception {
		try {
			this.close0();
		} catch (Exception ex) {
			throw ex;
		}

	}

	private void close0() throws MockSQLException, Exception {

		if (navigator == null) {
			return;
		}
		navigator.close();

		navigator = null;

		if (autoClose && statement != null) {
			statement.close();
		}
	}

	/**
	 * <!-- start generic documentation --> Reports whether the last column read had
	 * a value of SQL <code>NULL</code>. Note that you must first call one of the
	 * getter methods on a column to try to read its value and then call the method
	 * <code>wasNull</code> to see if the value read was SQL <code>NULL</code>. <!--
	 * end generic documentation -->
	 *
	 * @return <code>true</code> if the last column value read was SQL
	 *         <code>NULL</code> and <code>false</code> otherwise
	 * @exception MockSQLException
	 *                if a database access error occurs or this method is called on
	 *                a closed result set
	 */

	public boolean wasNull() throws MockSQLException, Exception {
		try {
			boolean rv = this.wasNull0();
			return rv;
		} catch (Exception ex) {
			throw ex;
		}

	}

	private boolean wasNull0() throws MockSQLException, Exception {

		checkClosed();

		return wasNullValue;
	}
	// ======================================================================
	// Methods for accessing results by column index
	// ======================================================================

	/**
	 * <!-- start generic documentation --> Retrieves the value of the designated
	 * column in the current row of this <code>ResultSet</code> object as an
	 * <code>int</code> in the Java programming language. <!-- end generic
	 * documentation -->
	 *
	 * <!-- start release-specific documentation -->
	 * <div class="ReleaseSpecificDocumentation">
	 * <h3>HSQLDB-Specific Information:</h3>
	 * <p>
	 *
	 * HSQLDB converts the numeric value to the return type. If the value is out of
	 * the range for the return type, an error is returned. For example, this can
	 * happen if getInt() or getLong() is used to retrieve a value of type DECIMAL
	 * or NUMERIC with a large precision and the value is beyond the range covered
	 * by the return type.
	 *
	 * </div> <!-- end release-specific documentation -->
	 * 
	 * @param columnIndex
	 *            the first column is 1, the second is 2, ...
	 * @return the column value; if the value is SQL <code>NULL</code>, the value
	 *         returned is <code>0</code>
	 * @exception MockSQLException
	 *                if a database access error occurs or this method is called on
	 *                a closed result set
	 */
	public int getInt(int columnIndex) throws MockSQLException, Exception {
		try {
			int rv = getInt0(columnIndex);
			return rv;
		} catch (Exception ex) {
			throw ex;
		}

	}

	private int getInt0(int columnIndex) throws MockSQLException, Exception {
		Object o = getColumnInType(columnIndex, MockType.SQL_INTEGER);

		return o == null ? 0 : ((Number) o).intValue();
	}

	// #endif

	// #endif

	// ======================================================================
	// Methods for accessing results by column label
	// ======================================================================

	/**
	 * <!-- start generic documentation --> Retrieves the value of the designated
	 * column in the current row of this <code>ResultSet</code> object as an
	 * <code>int</code> in the Java programming language. <!-- end generic
	 * documentation -->
	 *
	 * @param columnLabel
	 *            the label for the column specified with the SQL AS clause. If the
	 *            SQL AS clause was not specified, then the label is the name of the
	 *            column
	 * @return the column value; if the value is SQL <code>NULL</code>, the value
	 *         returned is <code>0</code>
	 * @exception MockSQLException
	 *                if a database access error occurs or this method is called on
	 *                a closed result set
	 */
	public int getInt(String columnLabel) throws MockSQLException, Exception {
		try {
			int rv = this.getInt0(columnLabel);
			return rv;
		} catch (Exception ex) {
			throw ex;
		}

	}

	private int getInt0(String columnLabel) throws MockSQLException, Exception {
		return getInt0(findColumn(columnLabel));
	}

	// #endif

	// #endif

	// =====================================================================
	// Advanced features:
	// =====================================================================

	/**
	 * <!-- start generic documentation --> Retrieves the first warning reported by
	 * calls on this <code>ResultSet</code> object. Subsequent warnings on this
	 * <code>ResultSet</code> object will be chained to the <code>SQLWarning</code>
	 * object that this method returns.
	 *
	 * <P>
	 * The warning chain is automatically cleared each time a new row is read. This
	 * method may not be called on a <code>ResultSet</code> object that has been
	 * closed; doing so will cause an <code>SQLException</code> to be thrown.
	 * <P>
	 * <B>Note:</B> This warning chain only covers warnings caused by
	 * <code>ResultSet</code> methods. Any warning caused by <code>Statement</code>
	 * methods (such as reading OUT parameters) will be chained on the
	 * <code>Statement</code> object. <!-- end generic documentation -->
	 *
	 * <!-- start release-specific documentation -->
	 * <div class="ReleaseSpecificDocumentation">
	 * <h3>HSQLDB-Specific Information:</h3>
	 * <p>
	 *
	 * HSQLDB does not produce <code>SQLWarning</code> objects on any ResultSet
	 * object warning chain; this method always returns <code>null</code>. </div>
	 * <!-- end release-specific documentation -->
	 *
	 * @return the first <code>SQLWarning</code> object reported or
	 *         <code>null</code> if there are none
	 * @exception MockSQLException
	 *                if a database access error occurs or this method is called on
	 *                a closed result set
	 */
//	public MockSQLWarning getWarnings() throws MockSQLException, Exception {
//		try {
//			MockSQLWarning rv = getWarnings0();
//			return rv;
//		} catch (Exception ex) {
//			throw ex;
//		}
//
//	}

//	private MockSQLWarning getWarnings0() throws MockSQLException, Exception {
//		checkClosed();
//		return rootWarning;
//	}

	/**
	 * <!-- start generic documentation --> Clears all warnings reported on this
	 * <code>ResultSet</code> object. After this method is called, the method
	 * <code>getWarnings</code> returns <code>null</code> until a new warning is
	 * reported for this <code>ResultSet</code> object. <!-- end generic
	 * documentation -->
	 *
	 * <!-- start release-specific documentation -->
	 * <div class="ReleaseSpecificDocumentation">
	 * <h3>HSQLDB-Specific Information:</h3>
	 * <p>
	 *
	 * HSQLDB does not produce <code>SQLWarning</code> objects on any ResultSet
	 * object warning chain; calls to this method are ignored. </div> <!-- end
	 * release-specific documentation -->
	 *
	 * @exception MockSQLException
	 *                if a database access error occurs or this method is called on
	 *                a closed result set
	 */
//	public void clearWarnings() throws MockSQLException, Exception {
//		try {
//			this.clearWarnings0();
//		} catch (Exception ex) {
//			throw ex;
//		}
//
//	}

//	private void clearWarnings0() throws MockSQLException, Exception {
//		checkClosed();
//		rootWarning = null;
//	}

	/**
	 * <!-- start generic documentation --> Retrieves the name of the SQL cursor
	 * used by this <code>ResultSet</code> object.
	 *
	 * <P>
	 * In SQL, a result table is retrieved through a cursor that is named. The
	 * current row of a result set can be updated or deleted using a positioned
	 * update/delete statement that references the cursor name. To insure that the
	 * cursor has the proper isolation level to support update, the cursor's
	 * <code>SELECT</code> statement should be of the form
	 * <code>SELECT FOR UPDATE</code>. If <code>FOR UPDATE</code> is omitted, the
	 * positioned updates may fail.
	 *
	 * <P>
	 * The JDBC API supports this SQL feature by providing the name of the SQL
	 * cursor used by a <code>ResultSet</code> object. The current row of a
	 * <code>ResultSet</code> object is also the current row of this SQL cursor.
	 * <!-- end generic documentation -->
	 *
	 * <!-- start release-specific documentation -->
	 * <div class="ReleaseSpecificDocumentation">
	 * <h3>HSQLDB-Specific Information:</h3>
	 * <p>
	 *
	 * HSQLDB supports this feature when the cursor has a name.
	 * <p>
	 *
	 * </div> <!-- end release-specific documentation -->
	 *
	 * @return the SQL name for this <code>ResultSet</code> object's cursor
	 * @exception MockSQLException
	 *                if a database access error occurs or this method is called on
	 *                a closed result set
	 * @exception SQLFeatureNotSupportedException
	 *                if the JDBC driver does not support this method
	 */
//	public String getCursorName() throws MockSQLException, Exception {
//		try {
//			String rv = this.getCursorName0();
//			return rv;
//		} catch (Exception ex) {
//			throw ex;
//		}
//
//	}

//	private String getCursorName0() throws MockSQLException, Exception {
//		checkClosed();
//		if (result == null) {
//			return "";
//		}
//		return result.getMainString();
//	}

	/**
	 * <!-- start generic documentation --> Retrieves the number, types and
	 * properties of this <code>ResultSet</code> object's columns. <!-- end generic
	 * documentation -->
	 *
	 * <!-- start release-specific documentation -->
	 * <div class="ReleaseSpecificDocumentation">
	 * <h3>HSQLDB-Specific Information:</h3>
	 * <p>
	 *
	 * <B>Example:</B>
	 * <p>
	 *
	 * The following code fragment creates a <code>ResultSet</code> object rs,
	 * creates a <code>ResultSetMetaData</code> object rsmd, and uses rsmd to find
	 * out how many columns rs has and whether the first column in rs can be used in
	 * a <code>WHERE</code> clause.
	 * <p>
	 *
	 * <pre class="JavaCodeExample">
	 * ResultSet rs   = stmt.<b>executeQuery</b>(<span class=
	"JavaStringLiteral">"SELECT a, b, c FROM TABLE2"</span>);
	 * ResultSetMetaData rsmd = rs.<b>getMetaData</b>();<br>
	 * int numberOfColumns = rsmd.<b>getColumnCount</b>();<br>
	 * boolean b = rsmd.<b>isSearchable</b>(1);<br>
	 * </pre>
	 *
	 * <hr>
	 *
	 * <B>Changes:</B>
	 * <p>
	 *
	 * With version 2.0, the engine's SQL implementation has been completely
	 * rewritten. Changes to this class and the implementation of ResultSetMetaData
	 * reflect the engine's new capabilities and provide more accurate information.
	 * <p>
	 *
	 * changes to consider:
	 * <p>
	 *
	 * <ol>
	 * <li>isAutoIncrement(int) <i>always</i> returned <code>false</code></li>
	 * <li>isNullable(int) returns the nullability of a real table or view column in
	 * the ResultSet and returns <code>columnNoNulls</code> for non-base-column
	 * ResultSet columns (columns of the ResultSet that are based on expressions or
	 * aggregates).</li>
	 * <li>getColumnDisplaySize(int) returns correct results even for expression
	 * columns.</li>
	 * <li>getPrecision(int) returns the correct precision even for expression
	 * columns.</li>
	 * <li>getScale(int) returns the correct precision even for expression
	 * columns.</li>
	 * <li>getCatalogName(int) returns the catalog name of the database.</li>
	 * </ol>
	 * <p>
	 *
	 * <hr>
	 * </div> <!-- end release-specific documentation -->
	 *
	 * @return the description of this <code>ResultSet</code> object's columns
	 * @exception MockSQLException
	 *                if a database access error occurs or this method is called on
	 *                a closed result set
	 * @see JDBCResultSetMetaData
	 */
//	public MockResultSetMetaData getMetaData() throws MockSQLException, Exception {
//		try {
//			MockResultSetMetaData rv = this.getMetaData0();
//			return rv;
//		} catch (Exception ex) {
//			throw ex;
//		}
//
//	}

//	private MockResultSetMetaData getMetaData0() throws MockSQLException, Exception {
//		checkClosed();
//		if (resultSetMetaData == null) {
//			resultSetMetaData = new MockJDBCResultSetMetaData(resultMetaData, isUpdatable, isInsertable, connection);
//		}
//		return resultSetMetaData;
//	}

	// ----------------------------------------------------------------

	/**
	 * <!-- start generic documentation --> Maps the given <code>ResultSet</code>
	 * column label to its <code>ResultSet</code> column index. <!-- end generic
	 * documentation -->
	 *
	 * <!-- start release-specific documentation -->
	 * <div class="ReleaseSpecificDocumentation">
	 * <h3>HSQLDB-Specific Information:</h3>
	 * <p>
	 *
	 * Starting with 1.9.x, HSQLDB does an exhaustive search, backed by a cache
	 * lookup (to improve performance for subsequent invocations with a given
	 * input).
	 * <p>
	 *
	 * This is in response to an observation posted here:
	 * <p>
	 *
	 * http://sourceforge.net/forum/forum.php?thread_id=1388727&forum_id=73674
	 * <p>
	 *
	 * Upon careful investigation of the JDBC specification and the behaviour of
	 * existing JDBC drivers, there is actually nothing preventing the findColumn
	 * method from doing an exhaustive search, as long as it conforms to the
	 * following rules (which describe the new implementation):
	 * <p>
	 *
	 * <ol>
	 * <li>the entire search is case insensitive
	 * <li>each search iteration occurs from leftmost to rightmost column, returning
	 * the first match encountered
	 * <li>the first pass matches only bare column labels
	 * <li>the second pass matches only simple column names
	 * <li>further passes conform to the identifier qualification and identifier
	 * quoting rules of the engine
	 * </ol>
	 *
	 * In this implementation, the SQL tokenizer is not employed, both because it
	 * does not yet correctly handle greater than two part qualification and also
	 * because is is not immediately considered important to do a truly exhaustive
	 * search, handling the full range of possibly mixed quoted and unquoted
	 * identifier components.
	 * <p>
	 *
	 * Instead:
	 * <p>
	 * <ul>
	 * <li>a third pass matches simple table-dot-column qualified names
	 * <li>a fourth pass matches simple schema-dot-table-dot-column qualified column
	 * names
	 * </ul>
	 * </div>
	 *
	 * @param columnLabel
	 *            the label for the column specified with the SQL AS clause. If the
	 *            SQL AS clause was not specified, then the label is the name of the
	 *            column
	 * @return the column index of the given column name
	 * @exception MockSQLException
	 *                if the <code>ResultSet</code> object does not contain a column
	 *                labeled <code>columnLabel</code>, a database access error
	 *                occurs or this method is called on a closed result set
	 */
	private int findColumn(final String columnLabel) throws MockSQLException, Exception {
		try {
			int rv = this.findColumn0(columnLabel);
			return rv;
		} catch (Exception ex) {
			throw ex;
		}

	}

	private int findColumn0(final String columnLabel) throws MockSQLException, Exception {

		checkClosed();

		if (columnLabel == null) {
			throw MockUtil.nullArgument();
		}

		int columnIndex;

		// faster lookup for subsequent access
		if (columnMap != null) {
			columnIndex = columnMap.get(columnLabel, -1);

			if (columnIndex != -1) {
				return columnIndex;
			}
		}

		final String[] colLabels = resultMetaData.columnLabels;

		columnIndex = -1;

		// column labels first, to preference column aliases
		for (int i = 0; i < columnCount; i++) {
			if (columnLabel.equalsIgnoreCase(colLabels[i])) {
				columnIndex = i;

				break;
			}
		}

		final MockColumnBase[] columns = resultMetaData.columns;

		// then bare column names, to preference simple
		// quoted column idents that *may* contain "."
		if (columnIndex < 0) {
			for (int i = 0; i < columnCount; i++) {
				if (columnLabel.equalsIgnoreCase(columns[i].getNameString())) {
					columnIndex = i;

					break;
				}
			}
		}

		// then table-qualified column names (again, quoted
		// table idents *may* contain "."
		// As a last resort, "fully" qualified column names
		// (we don't yet bother with catalog qualification)
		if (columnIndex < 0) {
			int position = columnLabel.indexOf('.');

			if (position < 0) {
				throw MockUtil.sqlException(MockErrorCode.JDBC_COLUMN_NOT_FOUND, columnLabel);
			}

			for (int i = 0; i < columnCount; i++) {
				final String tabName = columns[i].getTableNameString();

				if (tabName == null || tabName.length() == 0) {
					continue;
				}

				final String colName = columns[i].getNameString();

				if (columnLabel.equalsIgnoreCase(tabName + '.' + colName)) {
					columnIndex = i;

					break;
				}

				final String schemName = columns[i].getSchemaNameString();

				if (schemName == null || schemName.length() == 0) {
					continue;
				}

				String match = new StringBuffer(schemName).append('.').append(tabName).append('.').append(colName)
						.toString();

				if (columnLabel.equalsIgnoreCase(match)) {
					columnIndex = i;

					break;
				}
			}
		}

		if (columnIndex < 0) {
			throw MockUtil.sqlException(MockErrorCode.JDBC_COLUMN_NOT_FOUND, columnLabel);
		}
		columnIndex++;

		if (columnMap == null) {
			columnMap = new MockIntValueHashMap();
		}
		columnMap.put(columnLabel, columnIndex);

		return columnIndex;
	}

	// --------------------------JDBC 2.0-----------------------------------
	// ---------------------------------------------------------------------
	// Getters and Setters
	// ---------------------------------------------------------------------

	// ---------------------------------------------------------------------
	// Traversal/Positioning
	// ---------------------------------------------------------------------

	/**
	 * <!-- start generic documentation --> Retrieves whether the cursor is before
	 * the first row in this <code>ResultSet</code> object.
	 * <p>
	 * (JDBC4 Clarification:)
	 * <p>
	 * <strong>Note:</strong>Support for the <code>isBeforeFirst</code> method is
	 * optional for <code>ResultSet</code>s with a result set type of
	 * <code>TYPE_FORWARD_ONLY</code> <!-- end generic documentation -->
	 *
	 * @return <code>true</code> if the cursor is before the first row;
	 *         <code>false</code> if the cursor is at any other position or the
	 *         result set contains no rows
	 * @exception MockSQLException
	 *                if a database access error occurs or this method is called on
	 *                a closed result set
	 * @exception SQLFeatureNotSupportedException
	 *                if the JDBC driver does not support this method
	 * @since JDK 1.2 (JDK 1.1.x developers: read the overview for JDBCResultSet)
	 */
	public boolean isBeforeFirst() throws MockSQLException, Exception {
		try {
			boolean rv = isBeforeFirst0();
			return rv;
		} catch (Exception ex) {
			throw ex;
		}

	}

	private boolean isBeforeFirst0() throws MockSQLException, Exception {

		checkClosed();

		if (isOnInsertRow) {
			return false;
		}

		return navigator.isBeforeFirst();
	}

	/**
	 * <!-- start generic documentation --> Retrieves whether the cursor is after
	 * the last row in this <code>ResultSet</code> object.
	 * <p>
	 * (JDBC4 Clarification:)
	 * <p>
	 * <strong>Note:</strong>Support for the <code>isAfterLast</code> method is
	 * optional for <code>ResultSet</code>s with a result set type of
	 * <code>TYPE_FORWARD_ONLY</code> <!-- end generic documentation -->
	 *
	 * @return <code>true</code> if the cursor is after the last row;
	 *         <code>false</code> if the cursor is at any other position or the
	 *         result set contains no rows
	 * @exception MockSQLException
	 *                if a database access error occurs or this method is called on
	 *                a closed result set
	 * @exception SQLFeatureNotSupportedException
	 *                if the JDBC driver does not support this method
	 * @since JDK 1.2 (JDK 1.1.x developers: read the overview for JDBCResultSet)
	 */
	public boolean isAfterLast() throws MockSQLException, Exception {
		try {
			boolean rv = isAfterLast0();
			return rv;
		} catch (Exception ex) {
			throw ex;
		}

	}

	private boolean isAfterLast0() throws MockSQLException, Exception {

		// At afterLast condition exists when resultset has been traversed and
		// the current row is null. iCurrentRow should also be set to
		// afterlast but no need to test
		checkClosed();

		if (isOnInsertRow) {
			return false;
		}

		return navigator.isAfterLast();
	}

	/**
	 * <!-- start generic documentation --> Retrieves whether the cursor is on the
	 * first row of this <code>ResultSet</code> object.
	 * <p>
	 * (JDBC4 Clarification:)
	 * <p>
	 * <strong>Note:</strong>Support for the <code>isFirst</code> method is optional
	 * for <code>ResultSet</code>s with a result set type of
	 * <code>TYPE_FORWARD_ONLY</code> <!-- end generic documentation -->
	 *
	 * @return <code>true</code> if the cursor is on the first row;
	 *         <code>false</code> otherwise
	 * @exception MockSQLException
	 *                if a database access error occurs or this method is called on
	 *                a closed result set
	 * @exception SQLFeatureNotSupportedException
	 *                if the JDBC driver does not support this method
	 * @since JDK 1.2 (JDK 1.1.x developers: read the overview for JDBCResultSet)
	 */
	public boolean isFirst() throws MockSQLException, Exception {
		try {
			boolean rv = isFirst0();
			return rv;
		} catch (Exception ex) {
			throw ex;
		}

	}

	private boolean isFirst0() throws MockSQLException, Exception {

		checkClosed();

		if (isOnInsertRow) {
			return false;
		}

		return navigator.isFirst();
	}

	/**
	 * <!-- start generic documentation --> Retrieves whether the cursor is on the
	 * last row of this <code>ResultSet</code> object. <strong>Note:</strong>
	 * Calling the method <code>isLast</code> may be expensive because the JDBC
	 * driver might need to fetch ahead one row in order to determine whether the
	 * current row is the last row in the result set.
	 * <p>
	 * (JDBC4 Clarification:)
	 * <p>
	 * <strong>Note:</strong> Support for the <code>isLast</code> method is optional
	 * for <code>ResultSet</code>s with a result set type of
	 * <code>TYPE_FORWARD_ONLY</code> <!-- end generic documentation -->
	 *
	 * @return <code>true</code> if the cursor is on the last row;
	 *         <code>false</code> otherwise
	 * @exception MockSQLException
	 *                if a database access error occurs or this method is called on
	 *                a closed result set
	 * @exception SQLFeatureNotSupportedException
	 *                if the JDBC driver does not support this method
	 * @since JDK 1.2 (JDK 1.1.x developers: read the overview for JDBCResultSet)
	 */
	public boolean isLast() throws MockSQLException, Exception {
		try {
			boolean rv = isLast0();
			return rv;
		} catch (Exception ex) {
			throw ex;
		}

	}

	private boolean isLast0() throws MockSQLException, Exception {

		checkClosed();

		if (isOnInsertRow) {
			return false;
		}

		return navigator.isLast();
	}

	/**
	 * <!-- start generic documentation --> Moves the cursor to the front of this
	 * <code>ResultSet</code> object, just before the first row. This method has no
	 * effect if the result set contains no rows. <!-- end generic documentation -->
	 *
	 * @exception MockSQLException
	 *                if a database access error occurs, this method is called on a
	 *                closed result set or the result set type is
	 *                <code>TYPE_FORWARD_ONLY</code>
	 * @exception SQLFeatureNotSupportedException
	 *                if the JDBC driver does not support this method
	 * @since JDK 1.2 (JDK 1.1.x developers: read the overview for JDBCResultSet)
	 */
	public void beforeFirst() throws MockSQLException, Exception {
		try {
			this.beforeFirst0();
		} catch (Exception ex) {
			throw ex;
		}

	}

	private void beforeFirst0() throws MockSQLException, Exception {

		checkClosed();
		checkNotForwardOnly();

		if (isOnInsertRow || isRowUpdated) {
			throw MockUtil.sqlExceptionSQL(MockErrorCode.X_24513);
		}
		navigator.beforeFirst();
	}

	/**
	 * <!-- start generic documentation --> Moves the cursor to the end of this
	 * <code>ResultSet</code> object, just after the last row. This method has no
	 * effect if the result set contains no rows. <!-- end generic documentation -->
	 *
	 * @exception MockSQLException
	 *                if a database access error occurs, this method is called on a
	 *                closed result set or the result set type is
	 *                <code>TYPE_FORWARD_ONLY</code>
	 * @exception SQLFeatureNotSupportedException
	 *                if the JDBC driver does not support this method
	 * @since JDK 1.2 (JDK 1.1.x developers: read the overview for JDBCResultSet)
	 */
	public void afterLast() throws MockSQLException, Exception {
		try {
			this.afterLast0();
		} catch (Exception ex) {
			throw ex;
		}

	}

	private void afterLast0() throws MockSQLException, Exception {

		checkClosed();
		checkNotForwardOnly();

		if (isOnInsertRow || isRowUpdated) {
			throw MockUtil.sqlExceptionSQL(MockErrorCode.X_24513);
		}
		navigator.afterLast();
	}

	/**
	 * <!-- start generic documentation --> Moves the cursor to the first row in
	 * this <code>ResultSet</code> object. <!-- end generic documentation -->
	 *
	 * @return <code>true</code> if the cursor is on a valid row; <code>false</code>
	 *         if there are no rows in the result set
	 * @exception MockSQLException
	 *                if a database access error occurs, this method is called on a
	 *                closed result set or the result set type is
	 *                <code>TYPE_FORWARD_ONLY</code>
	 * @exception SQLFeatureNotSupportedException
	 *                if the JDBC driver does not support this method
	 * @since JDK 1.2 (JDK 1.1.x developers: read the overview for JDBCResultSet)
	 */
	public boolean first() throws MockSQLException, Exception {
		try {
			boolean rv = this.first0();
			return rv;
		} catch (Exception ex) {
			throw ex;
		}

	}

	private boolean first0() throws MockSQLException, Exception {

		checkClosed();
		checkNotForwardOnly();

		if (isOnInsertRow || isRowUpdated) {
			throw MockUtil.sqlExceptionSQL(MockErrorCode.X_24513);
		}

		return navigator.first();
	}

	/**
	 * <!-- start generic documentation --> Moves the cursor to the last row in this
	 * <code>ResultSet</code> object. <!-- end generic documentation -->
	 *
	 * @return <code>true</code> if the cursor is on a valid row; <code>false</code>
	 *         if there are no rows in the result set
	 * @exception MockSQLException
	 *                if a database access error occurs, this method is called on a
	 *                closed result set or the result set type is
	 *                <code>TYPE_FORWARD_ONLY</code>
	 * @exception SQLFeatureNotSupportedException
	 *                if the JDBC driver does not support this method
	 * @since JDK 1.2 (JDK 1.1.x developers: read the overview for JDBCResultSet)
	 */
	public boolean last() throws MockSQLException, Exception {
		try {
			boolean rv = last0();
			return rv;
		} catch (Exception ex) {
			throw ex;
		}

	}

	private boolean last0() throws MockSQLException, Exception {

		checkClosed();
		checkNotForwardOnly();

		if (isOnInsertRow || isRowUpdated) {
			throw MockUtil.sqlExceptionSQL(MockErrorCode.X_24513);
		}

		return navigator.last();
	}

	/**
	 * <!-- start generic documentation --> Retrieves the current row number. The
	 * first row is number 1, the second number 2, and so on.
	 * <p>
	 * (JDBC4 Clarification:)
	 * <p>
	 * <strong>Note:</strong>Support for the <code>getRow</code> method is optional
	 * for <code>ResultSet</code>s with a result set type of
	 * <code>TYPE_FORWARD_ONLY</code> <!-- end generic documentation -->
	 *
	 * @return the current row number; <code>0</code> if there is no current row
	 * @exception MockSQLException
	 *                if a database access error occurs or this method is called on
	 *                a closed result set
	 * @exception SQLFeatureNotSupportedException
	 *                if the JDBC driver does not support this method
	 * @since JDK 1.2 (JDK 1.1.x developers: read the overview for JDBCResultSet)
	 */
	public int getRow() throws MockSQLException, Exception {
		try {
			int rv = getRow0();
			return rv;
		} catch (Exception ex) {
			throw ex;
		}

	}

	private int getRow0() throws MockSQLException, Exception {

		checkClosed();

		if (navigator.isAfterLast()) {
			return 0;
		}

		return navigator.getRowNumber() + 1;
	}

	/**
	 * <!-- start generic documentation --> Moves the cursor to the given row number
	 * in this <code>ResultSet</code> object.
	 *
	 * <p>
	 * If the row number is positive, the cursor moves to the given row number with
	 * respect to the beginning of the result set. The first row is row 1, the
	 * second is row 2, and so on.
	 *
	 * <p>
	 * If the given row number is negative, the cursor moves to an absolute row
	 * position with respect to the end of the result set. For example, calling the
	 * method <code>absolute(-1)</code> positions the cursor on the last row;
	 * calling the method <code>absolute(-2)</code> moves the cursor to the
	 * next-to-last row, and so on.
	 *
	 * <p>
	 * An attempt to position the cursor beyond the first/last row in the result set
	 * leaves the cursor before the first row or after the last row.
	 *
	 * <p>
	 * <B>Note:</B> Calling <code>absolute(1)</code> is the same as calling
	 * <code>first()</code>. Calling <code>absolute(-1)</code> is the same as
	 * calling <code>last()</code>. <!-- end generic documentation -->
	 *
	 * @param row
	 *            the number of the row to which the cursor should move. A positive
	 *            number indicates the row number counting from the beginning of the
	 *            result set; a negative number indicates the row number counting
	 *            from the end of the result set
	 * @return <code>true</code> if the cursor is moved to a position in this
	 *         <code>ResultSet</code> object; <code>false</code> if the cursor is
	 *         before the first row or after the last row
	 * @exception MockSQLException
	 *                if a database access error occurs, this method is called on a
	 *                closed result set or the result set type is
	 *                <code>TYPE_FORWARD_ONLY</code>
	 * @exception SQLFeatureNotSupportedException
	 *                if the JDBC driver does not support this method
	 * @since JDK 1.2 (JDK 1.1.x developers: read the overview for JDBCResultSet)
	 */
	public boolean absolute(int row) throws MockSQLException, Exception {
		try {
			boolean rv = this.absolute0(row);
			return rv;
		} catch (Exception ex) {
			throw ex;
		}
	}

	private boolean absolute0(int row) throws MockSQLException, Exception {

		checkClosed();
		checkNotForwardOnly();

		if (isOnInsertRow || isRowUpdated) {
			throw MockUtil.sqlExceptionSQL(MockErrorCode.X_24513);
		}

		if (row > 0) {
			row--;
		} else if (row == 0) {
			return navigator.beforeFirst();
		}

		return navigator.absolute(row);
	}

	/**
	 * <!-- start generic documentation --> Moves the cursor a relative number of
	 * rows, either positive or negative. Attempting to move beyond the first/last
	 * row in the result set positions the cursor before/after the the first/last
	 * row. Calling <code>relative(0)</code> is valid, but does not change the
	 * cursor position.
	 *
	 * <p>
	 * Note: Calling the method <code>relative(1)</code> is identical to calling the
	 * method <code>next()</code> and calling the method <code>relative(-1)</code>
	 * is identical to calling the method <code>previous()</code>. <!-- end generic
	 * documentation -->
	 *
	 * @param rows
	 *            an <code>int</code> specifying the number of rows to move from the
	 *            current row; a positive number moves the cursor forward; a
	 *            negative number moves the cursor backward
	 * @return <code>true</code> if the cursor is on a row; <code>false</code>
	 *         otherwise
	 * @exception MockSQLException
	 *                if a database access error occurs, this method is called on a
	 *                closed result set, there is no current row, or the result set
	 *                type is <code>TYPE_FORWARD_ONLY</code>
	 * @exception SQLFeatureNotSupportedException
	 *                if the JDBC driver does not support this method
	 * @since JDK 1.2 (JDK 1.1.x developers: read the overview for JDBCResultSet)
	 */
	public boolean relative(int rows) throws MockSQLException, Exception {
		try {
			boolean rv = relative0(rows);
			return rv;
		} catch (Exception ex) {
			throw ex;
		}

	}

	private boolean relative0(int rows) throws MockSQLException, Exception {

		checkClosed();
		checkNotForwardOnly();

		if (isOnInsertRow || isRowUpdated) {
			throw MockUtil.sqlExceptionSQL(MockErrorCode.X_24513);
		}

		return navigator.relative(rows);
	}

	/**
	 * <!-- start generic documentation --> Moves the cursor to the previous row in
	 * this <code>ResultSet</code> object.
	 * <p>
	 * (JDBC4 clarification:) When a call to the <code>previous</code> method
	 * returns <code>false</code>, the cursor is positioned before the first row.
	 * Any invocation of a <code>ResultSet</code> method which requires a current
	 * row will result in a <code>SQLException</code> being thrown.
	 * <p>
	 * (JDBC4 clarification:) If an input stream is open for the current row, a call
	 * to the method <code>previous</code> will implicitly close it. A
	 * <code>ResultSet</code> object's warning change is cleared when a new row is
	 * read.
	 * <p>
	 * <!-- end generic documentation -->
	 *
	 * @return (JDBC4 clarification:) <code>true</code> if the cursor is now
	 *         positioned on a valid row; <code>false</code> if the cursor is
	 *         positioned before the first row
	 * @exception MockSQLException
	 *                if a database access error occurs; this method is called on a
	 *                closed result set or the result set type is
	 *                <code>TYPE_FORWARD_ONLY</code>
	 * @exception SQLFeatureNotSupportedException
	 *                if the JDBC driver does not support this method
	 * @since JDK 1.2 (JDK 1.1.x developers: read the overview for JDBCResultSet)
	 */
	public boolean previous() throws MockSQLException, Exception {
		try {
			boolean rv = previous0();
			return rv;
		} catch (Exception ex) {
			throw ex;
		}

	}

	private boolean previous0() throws MockSQLException, Exception {

		checkClosed();
		checkNotForwardOnly();

		if (isOnInsertRow || isRowUpdated) {
			throw MockUtil.sqlExceptionSQL(MockErrorCode.X_24513);
		}
		rootWarning = null;

		return navigator.previous();
	}

	// ---------------------------------------------------------------------
	// Properties
	// ---------------------------------------------------------------------

	/**
	 * <!-- start generic documentation --> Gives a hint as to the direction in
	 * which the rows in this <code>ResultSet</code> object will be processed. The
	 * initial value is determined by the <code>Statement</code> object that
	 * produced this <code>ResultSet</code> object. The fetch direction may be
	 * changed at any time. <!-- end generic documentation -->
	 *
	 * <!-- start release-specific documentation -->
	 * <div class="ReleaseSpecificDocumentation">
	 * <h3>HSQLDB-Specific Information:</h3>
	 * <p>
	 *
	 * HSQLDB does not need this hint. However, as mandated by the JDBC standard, an
	 * MockSQLException is thrown if the result set type is TYPE_FORWARD_ONLY and a
	 * fetch direction other than FETCH_FORWARD is requested.
	 * <p>
	 * </div> <!-- end release-specific documentation -->
	 *
	 * @param direction
	 *            an <code>int</code> specifying the suggested fetch direction; one
	 *            of <code>ResultSet.FETCH_FORWARD</code>,
	 *            <code>ResultSet.FETCH_REVERSE</code>, or
	 *            <code>ResultSet.FETCH_UNKNOWN</code>
	 * @exception MockSQLException
	 *                if a database access error occurs; this method is called on a
	 *                closed result set or the result set type is
	 *                <code>TYPE_FORWARD_ONLY</code> and the fetch direction is not
	 *                <code>FETCH_FORWARD</code>
	 * @since JDK 1.2 (JDK 1.1.x developers: read the overview for JDBCResultSet)
	 * @see JDBCStatement#setFetchDirection
	 * @see #getFetchDirection
	 */
//	public void setFetchDirection(int direction) throws MockSQLException, Exception {
//		try {
//			this.setFetchDirection0(direction);
//		} catch (Exception ex) {
//			throw ex;
//		}
//
//	}

//	private void setFetchDirection0(int direction) throws MockSQLException, Exception {
//		checkClosed();
//		switch (direction) {
//		case FETCH_FORWARD: {
//			break;
//		}
//		case FETCH_REVERSE: {
//			checkNotForwardOnly();
//			break;
//		}
//		case FETCH_UNKNOWN: {
//			checkNotForwardOnly();
//			break;
//		}
//		default: {
//			throw MockUtil.notSupported();
//		}
//		}
//	}

	/**
	 * <!-- start generic documentation --> Retrieves the fetch direction for this
	 * <code>ResultSet</code> object. <!-- end generic documentation -->
	 *
	 * <!-- start release-specific documentation -->
	 * <div class="ReleaseSpecificDocumentation">
	 * <h3>HSQLDB-Specific Information:</h3>
	 * <p>
	 *
	 * HSQLDB does not depend on fetch direction and always returns
	 * <code>FETCH_FORWARD</code>, but the value has no real meaning.
	 * <p>
	 * </div> <!-- end release-specific documentation -->
	 *
	 * @return the current fetch direction for this <code>ResultSet</code> object
	 * @exception MockSQLException
	 *                if a database access error occurs or this method is called on
	 *                a closed result set
	 * @since JDK 1.2 (JDK 1.1.x developers: read the overview for JDBCResultSet)
	 * @see #setFetchDirection
	 */
//	public int getFetchDirection() throws MockSQLException, Exception {
//		try {
//			int rv = this.getFetchDirection0();
//			return rv;
//		} catch (Exception ex) {
//			throw ex;
//		}
//
//	}

//	private int getFetchDirection0() throws MockSQLException, Exception {
//		checkClosed();
//		return FETCH_FORWARD;
//	}

	/**
	 * <!-- start generic documentation --> Gives the JDBC driver a hint as to the
	 * number of rows that should be fetched from the database when more rows are
	 * needed for this <code>ResultSet</code> object. If the fetch size specified is
	 * zero, the JDBC driver ignores the value and is free to make its own best
	 * guess as to what the fetch size should be. The default value is set by the
	 * <code>Statement</code> object that created the result set. The fetch size may
	 * be changed at any time. <!-- end generic documentation -->
	 *
	 * <!-- start release-specific documentation -->
	 * <div class="ReleaseSpecificDocumentation">
	 * <h3>HSQLDB-Specific Information:</h3>
	 * <p>
	 *
	 * HSQLDB may not build and return a result set as a whole. Therefore the
	 * supplied, non-zero, fetch size value is used for some ResultSet objects.
	 * </div> <!-- end release-specific documentation -->
	 *
	 * @param rows
	 *            the number of rows to fetch
	 * @exception MockSQLException
	 *                if a database access error occurs; this method (JDBC4
	 *                Clarification:) is called on a closed result set or the (JDBC4
	 *                clarification:) condition <code>rows >= 0 </code> is not
	 *                satisfied
	 * @since JDK 1.2 (JDK 1.1.x developers: read the overview for JDBCResultSet)
	 * @see #getFetchSize
	 * @see JDBCStatement#setFetchSize
	 * @see JDBCStatement#getFetchSize
	 */
//	public void setFetchSize(int rows) throws MockSQLException, Exception {
//		try {
//			this.setFetchSize0(rows);
//		} catch (Exception ex) {
//			throw ex;
//		}
//
//	}

//	private void setFetchSize0(int rows) throws MockSQLException, Exception {
//		if (rows < 0) {
//			throw MockUtil.outOfRangeArgument();
//		}
//	}

	/**
	 * <!-- start generic documentation --> Retrieves the fetch size for this
	 * <code>ResultSet</code> object. <!-- end generic documentation -->
	 *
	 * <!-- start release-specific documentation -->
	 * <div class="ReleaseSpecificDocumentation">
	 * <h3>HSQLDB-Specific Information:</h3>
	 * <p>
	 *
	 * HSQLDB may not build and return a result set as a whole. The acutal fetch
	 * size for this result set is returned. </div> <!-- end release-specific
	 * documentation -->
	 *
	 * @return the current fetch size for this <code>ResultSet</code> object
	 * @exception MockSQLException
	 *                if a database access error occurs or this method is called on
	 *                a closed result set
	 * @since JDK 1.2 (JDK 1.1.x developers: read the overview for JDBCResultSet)
	 * @see #setFetchSize
	 * @see JDBCStatement#getFetchSize
	 * @see JDBCStatement#setFetchSize
	 */
//	public int getFetchSize() throws MockSQLException, Exception {
//		try {
//			int rv = this.getFetchSize0();
//			return rv;
//		} catch (Exception ex) {
//			throw ex;
//		}
//
//	}

//	private int getFetchSize0() throws MockSQLException, Exception {
//		checkClosed();
//		return fetchSize;
//	}

	/**
	 * <!-- start generic documentation --> Retrieves the concurrency mode of this
	 * <code>ResultSet</code> object. The concurrency used is determined by the
	 * <code>Statement</code> object that created the result set. <!-- end generic
	 * documentation -->
	 *
	 * <!-- start release-specific documentation -->
	 * <div class="ReleaseSpecificDocumentation">
	 * <h3>HSQLDB-Specific Information:</h3>
	 * <p>
	 *
	 * HSQLDB supports updatable result sets and accurately reports the actual
	 * runtime concurrency of this result set instance. </div> <!-- end
	 * release-specific documentation -->
	 *
	 * @return the concurrency type, either <code>ResultSet.CONCUR_READ_ONLY</code>
	 *         or <code>ResultSet.CONCUR_UPDATABLE</code>
	 * @exception MockSQLException
	 *                if a database access error occurs or this method is called on
	 *                a closed result set
	 * @since JDK 1.2 (JDK 1.1.x developers: read the overview for JDBCResultSet)
	 */
//	public int getConcurrency() throws MockSQLException, Exception {
//		try {
//			int rv = this.getConcurrency0();
//			return rv;
//		} catch (Exception ex) {
//			throw ex;
//		}
//
//	}

//	private int getConcurrency0() throws MockSQLException, Exception {
//		checkClosed();
//		return MockResultProperties.getJDBCConcurrency(rsProperties);
//	}

	// ---------------------------------------------------------------------
	// Updates
	// ---------------------------------------------------------------------

	/**
	 * <!-- start generic documentation --> Retrieves whether the current row has
	 * been updated. The value returned depends on whether or not the result set can
	 * detect updates. <!-- end generic documentation -->
	 *
	 * <!-- start release-specific documentation -->
	 * <div class="ReleaseSpecificDocumentation">
	 * <h3>HSQLDB-Specific Information:</h3>
	 * <p>
	 *
	 * HSQLDB supports updatable result sets and accurately reports the actual
	 * value. </div> <!-- end release-specific documentation -->
	 *
	 * @return <code>true</code> if the current row is detected to have been visibly
	 *         updated by the owner or another; <code>false</code> otherwise
	 * @exception MockSQLException
	 *                if a database access error occurs, the result set concurrency
	 *                is <code>CONCUR_READ_ONLY</code> or this method is called on a
	 *                closed result set
	 * @exception SQLFeatureNotSupportedException
	 *                if the JDBC driver does not support this method
	 * @see JDBCDatabaseMetaData#updatesAreDetected
	 * @since JDK 1.2 (JDK 1.1.x developers: read the overview for JDBCResultSet)
	 */
//	public boolean rowUpdated() throws MockSQLException, Exception {
//		try {
//			boolean rv = this.rowUpdated0();
//			return rv;
//		} catch (Exception ex) {
//			throw ex;
//		}
//
//	}

//	private boolean rowUpdated0() throws MockSQLException, Exception {
//		checkClosed();
//		return isRowUpdated;
//	}

	/**
	 * <!-- start generic documentation --> Retrieves whether the current row has
	 * had an insertion. The value returned depends on whether or not this
	 * <code>ResultSet</code> object can detect visible inserts. <!-- end generic
	 * documentation -->
	 *
	 * <!-- start release-specific documentation -->
	 * <div class="ReleaseSpecificDocumentation">
	 * <h3>HSQLDB-Specific Information:</h3>
	 * <p>
	 *
	 * HSQLDB supports updatable result sets and accurately reports the actual
	 * value. </div> <!-- end release-specific documentation -->
	 *
	 * @return <code>true</code> if the current row is detected to have been
	 *         inserted; <code>false</code> otherwise
	 * @exception MockSQLException
	 *                if a database access error occurs, the result set concurrency
	 *                is <code>CONCUR_READ_ONLY</code> or this method is called on a
	 *                closed result set
	 * @exception SQLFeatureNotSupportedException
	 *                if the JDBC driver does not support this method
	 * @see JDBCDatabaseMetaData#insertsAreDetected
	 * @since JDK 1.2 (JDK 1.1.x developers: read the overview for JDBCResultSet)
	 */
//	public boolean rowInserted() throws MockSQLException, Exception {
//		try {
//			boolean rv = this.rowInserted0();
//			return rv;
//		} catch (Exception ex) {
//			throw ex;
//		}
//
//	}

//	private boolean rowInserted0() throws MockSQLException, Exception {
//		checkClosed();
//		return false;
//	}

	/**
	 * <!-- start generic documentation --> Retrieves whether a row has been
	 * deleted. A deleted row may leave a visible "hole" in a result set. This
	 * method can be used to detect holes in a result set. The value returned
	 * depends on whether or not this <code>ResultSet</code> object can detect
	 * deletions.
	 * <p>
	 * (JDBC4 Clarification:)
	 * <p>
	 * <strong>Note:</strong> Support for the <code>rowDeleted</code> method is
	 * optional with a result set concurrency of <code>CONCUR_READ_ONLY</code> <!--
	 * end generic documentation -->
	 *
	 * <!-- start release-specific documentation -->
	 * <div class="ReleaseSpecificDocumentation">
	 * <h3>HSQLDB-Specific Information:</h3>
	 * <p>
	 *
	 * HSQLDB supports updatable result sets and accurately reports the actual
	 * value. </div> <!-- end release-specific documentation -->
	 * 
	 * @return <code>true</code> if the current row is detected to have been deleted
	 *         by the owner or another; <code>false</code> otherwise
	 * @exception MockSQLException
	 *                if a database access error occurs or this method is called on
	 *                a closed result set
	 * @exception SQLFeatureNotSupportedException
	 *                if the JDBC driver does not support this method
	 * @see JDBCDatabaseMetaData#deletesAreDetected
	 * @since JDK 1.2 (JDK 1.1.x developers: read the overview for JDBCResultSet)
	 */
//	public boolean rowDeleted() throws MockSQLException, Exception {
//		try {
//			boolean rv = this.rowDeleted0();
//			return rv;
//		} catch (Exception ex) {
//			throw ex;
//		}
//
//	}

//	private boolean rowDeleted0() throws MockSQLException, Exception {
//		checkClosed();
//		return false;
//	}

	/**
	 * <!-- start generic documentation --> Updates the designated column with an
	 * <code>int</code> value. The updater methods are used to update column values
	 * in the current row or the insert row. The updater methods do not update the
	 * underlying database; instead the <code>updateRow</code> or
	 * <code>insertRow</code> methods are called to update the database. <!-- end
	 * generic documentation -->
	 *
	 * <!-- start release-specific documentation -->
	 * <div class="ReleaseSpecificDocumentation">
	 * <h3>HSQLDB-Specific Information:</h3>
	 * <p>
	 *
	 * HSQLDB supports this feature.
	 * <p>
	 * </div> <!-- end release-specific documentation -->
	 *
	 * @param columnIndex
	 *            the first column is 1, the second is 2, ...
	 * @param x
	 *            the new column value
	 * @exception MockSQLException
	 *                if a database access error occurs, the result set concurrency
	 *                is <code>CONCUR_READ_ONLY</code> or this method is called on a
	 *                closed result set
	 * @exception SQLFeatureNotSupportedException
	 *                if the JDBC driver does not support this method
	 * @since JDK 1.2 (JDK 1.1.x developers: read the overview for JDBCResultSet)
	 */
	public void updateInt(int columnIndex, int x) throws MockSQLException, Exception {
		try {
			this.updateInt0(columnIndex, x);
		} catch (Exception ex) {
			throw ex;
		}

	}

	private void updateInt0(int columnIndex, int x) throws MockSQLException, Exception {
		startUpdate(columnIndex);
		preparedStatement.setIntParameter(columnIndex, x);
	}

	/**
	 * <!-- start generic documentation --> Updates the designated column with an
	 * <code>int</code> value. The updater methods are used to update column values
	 * in the current row or the insert row. The updater methods do not update the
	 * underlying database; instead the <code>updateRow</code> or
	 * <code>insertRow</code> methods are called to update the database. <!-- end
	 * generic documentation -->
	 *
	 * <!-- start release-specific documentation -->
	 * <div class="ReleaseSpecificDocumentation">
	 * <h3>HSQLDB-Specific Information:</h3>
	 * <p>
	 *
	 * HSQLDB supports this feature.
	 * <p>
	 * </div> <!-- end release-specific documentation -->
	 *
	 * @param columnLabel
	 *            the label for the column specified with the SQL AS clause. If the
	 *            SQL AS clause was not specified, then the label is the name of the
	 *            column
	 * @param x
	 *            the new column value
	 * @exception MockSQLException
	 *                if a database access error occurs, the result set concurrency
	 *                is <code>CONCUR_READ_ONLY</code> or this method is called on a
	 *                closed result set
	 * @exception SQLFeatureNotSupportedException
	 *                if the JDBC driver does not support this method
	 * @since JDK 1.2 (JDK 1.1.x developers: read the overview for JDBCResultSet)
	 */
	public void updateInt(String columnLabel, int x) throws MockSQLException, Exception {
		try {
			this.updateInt0(columnLabel, x);
		} catch (Exception ex) {
			throw ex;
		}

	}

	private void updateInt0(String columnLabel, int x) throws MockSQLException, Exception {
		updateInt(findColumn(columnLabel), x);
	}

	/**
	 * <!-- start generic documentation --> Inserts the contents of the insert row
	 * into this <code>ResultSet</code> object and into the database. The cursor
	 * must be on the insert row when this method is called. <!-- end generic
	 * documentation -->
	 *
	 * <!-- start release-specific documentation -->
	 * <div class="ReleaseSpecificDocumentation">
	 * <h3>HSQLDB-Specific Information:</h3>
	 * <p>
	 *
	 * HSQLDB supports this feature.
	 * <p>
	 * </div> <!-- end release-specific documentation -->
	 *
	 * @exception MockSQLException
	 *                if a database access error occurs, the result set concurrency
	 *                is <code>CONCUR_READ_ONLY</code>, this method is called on a
	 *                closed result set, if this method is called when the cursor is
	 *                not on the insert row, or if not all of non-nullable columns
	 *                in the insert row have been given a non-null value
	 * @exception SQLFeatureNotSupportedException
	 *                if the JDBC driver does not support this method
	 * @since JDK 1.2 (JDK 1.1.x developers: read the overview for JDBCResultSet)
	 */
	public void insertRow() throws MockSQLException, Exception {
		try {
			insertRow0();
		} catch (Exception ex) {
			throw ex;
		}

	}

	private void insertRow0() throws MockSQLException, Exception {
		performInsert();
	}

	/**
	 * <!-- start generic documentation --> Updates the underlying database with the
	 * new contents of the current row of this <code>ResultSet</code> object. This
	 * method cannot be called when the cursor is on the insert row. <!-- end
	 * generic documentation -->
	 *
	 * <!-- start release-specific documentation -->
	 * <div class="ReleaseSpecificDocumentation">
	 * <h3>HSQLDB-Specific Information:</h3>
	 * <p>
	 *
	 * HSQLDB supports this feature.
	 * <p>
	 *
	 * After updating any values in the current row, it is not possible to move the
	 * cursor position without calling this method, or alternatively calling
	 * cancelRowUpdates() to abandon the row update. </div> <!-- end
	 * release-specific documentation -->
	 *
	 * @exception MockSQLException
	 *                if a database access error occurs; the result set concurrency
	 *                is <code>CONCUR_READ_ONLY</code>; this method is called on a
	 *                closed result set or if this method is called when the cursor
	 *                is on the insert row
	 * @exception SQLFeatureNotSupportedException
	 *                if the JDBC driver does not support this method
	 * @since JDK 1.2 (JDK 1.1.x developers: read the overview for JDBCResultSet)
	 */
	public void updateRow() throws MockSQLException, Exception {
		try {
			this.updateRow0();
		} catch (Exception ex) {
			throw ex;
		}

	}

	private void updateRow0() throws MockSQLException, Exception {
		performUpdate();
	}

	/**
	 * <!-- start generic documentation --> Deletes the current row from this
	 * <code>ResultSet</code> object and from the underlying database. This method
	 * cannot be called when the cursor is on the insert row. <!-- end generic
	 * documentation -->
	 *
	 * <!-- start release-specific documentation -->
	 * <div class="ReleaseSpecificDocumentation">
	 * <h3>HSQLDB-Specific Information:</h3>
	 * <p>
	 *
	 * HSQLDB supports this feature.
	 * <p>
	 *
	 * After a successful call to this method, the row is deleted. </div> <!-- end
	 * release-specific documentation -->
	 *
	 * @exception MockSQLException
	 *                if a database access error occurs; the result set concurrency
	 *                is <code>CONCUR_READ_ONLY</code>; this method is called on a
	 *                closed result set or if this method is called when the cursor
	 *                is on the insert row
	 * @exception SQLFeatureNotSupportedException
	 *                if the JDBC driver does not support this method
	 * @since JDK 1.2 (JDK 1.1.x developers: read the overview for JDBCResultSet)
	 */
	public void deleteRow() throws MockSQLException, Exception {
		try {
			this.deleteRow0();
		} catch (Exception ex) {
			throw ex;
		}

	}

	private void deleteRow0() throws MockSQLException, Exception {
		performDelete();
	}

	/** @todo - fredt - implement */

	/**
	 * <!-- start generic documentation --> Refreshes the current row with its most
	 * recent value in the database. This method cannot be called when the cursor is
	 * on the insert row.
	 *
	 * <P>
	 * The <code>refreshRow</code> method provides a way for an application to
	 * explicitly tell the JDBC driver to refetch a row(s) from the database. An
	 * application may want to call <code>refreshRow</code> when caching or
	 * prefetching is being done by the JDBC driver to fetch the latest value of a
	 * row from the database. The JDBC driver may actually refresh multiple rows at
	 * once if the fetch size is greater than one.
	 *
	 * <P>
	 * All values are refetched subject to the transaction isolation level and
	 * cursor sensitivity. If <code>refreshRow</code> is called after calling an
	 * updater method, but before calling the method <code>updateRow</code>, then
	 * the updates made to the row are lost. Calling the method
	 * <code>refreshRow</code> frequently will likely slow performance. <!-- end
	 * generic documentation -->
	 *
	 * <!-- start release-specific documentation -->
	 * <div class="ReleaseSpecificDocumentation">
	 * <h3>HSQLDB-Specific Information:</h3>
	 * <p>
	 *
	 * HSQLDB supports this feature.
	 * <p>
	 * </div> <!-- end release-specific documentation -->
	 *
	 * @exception MockSQLException
	 *                if a database access error occurs; this method is called on a
	 *                closed result set; the result set type is
	 *                <code>TYPE_FORWARD_ONLY</code> or if this method is called
	 *                when the cursor is on the insert row
	 * @exception SQLFeatureNotSupportedException
	 *                if the JDBC driver does not support this method or this method
	 *                is not supported for the specified result set type and result
	 *                set concurrency.
	 * @since JDK 1.2 (JDK 1.1.x developers: read the overview for JDBCResultSet)
	 */
	public void refreshRow() throws MockSQLException, Exception {
		try {
			this.refreshRow0();
		} catch (Exception ex) {
			throw ex;
		}

	}

	private void refreshRow0() throws MockSQLException, Exception {
		clearUpdates();
	}

//	public int getType() throws MockSQLException, Exception {
//		try {
//			int rv = getType0();
//			return rv;
//		} catch (Exception ex) {
//			throw ex;
//		}
//	}

//	private int getType0() throws MockSQLException, Exception {
//		checkClosed();
//		return MockResultProperties.getJDBCScrollability(rsProperties);
//	}

	/**
	 * <!-- start generic documentation --> Cancels the updates made to the current
	 * row in this <code>ResultSet</code> object. This method may be called after
	 * calling an updater method(s) and before calling the method
	 * <code>updateRow</code> to roll back the updates made to a row. If no updates
	 * have been made or <code>updateRow</code> has already been called, this method
	 * has no effect. <!-- end generic documentation -->
	 *
	 * <!-- start release-specific documentation -->
	 * <div class="ReleaseSpecificDocumentation">
	 * <h3>HSQLDB-Specific Information:</h3>
	 * <p>
	 *
	 * HSQLDB supports this feature.
	 * <p>
	 * </div> <!-- end release-specific documentation -->
	 *
	 * @exception MockSQLException
	 *                if a database access error occurs; this method is called on a
	 *                closed result set; the result set concurrency is
	 *                <code>CONCUR_READ_ONLY</code> or if this method is called when
	 *                the cursor is on the insert row
	 * @exception SQLFeatureNotSupportedException
	 *                if the JDBC driver does not support this method
	 * @since JDK 1.2 (JDK 1.1.x developers: read the overview for JDBCResultSet)
	 */
	public void cancelRowUpdates() throws MockSQLException, Exception {
		try {
			this.cancelRowUpdates0();
		} catch (Exception ex) {
			throw ex;
		}

	}

	private void cancelRowUpdates0() throws MockSQLException, Exception {
		clearUpdates();
	}

	/**
	 * <!-- start generic documentation --> Moves the cursor to the insert row. The
	 * current cursor position is remembered while the cursor is positioned on the
	 * insert row.
	 *
	 * The insert row is a special row associated with an updatable result set. It
	 * is essentially a buffer where a new row may be constructed by calling the
	 * updater methods prior to inserting the row into the result set.
	 *
	 * Only the updater, getter, and <code>insertRow</code> methods may be called
	 * when the cursor is on the insert row. All of the columns in a result set must
	 * be given a value each time this method is called before calling
	 * <code>insertRow</code>. An updater method must be called before a getter
	 * method can be called on a column value. <!-- end generic documentation -->
	 *
	 * <!-- start release-specific documentation -->
	 * <div class="ReleaseSpecificDocumentation">
	 * <h3>HSQLDB-Specific Information:</h3>
	 * <p>
	 *
	 * HSQLDB supports this feature.
	 * <p>
	 * </div> <!-- end release-specific documentation -->
	 *
	 * @exception MockSQLException
	 *                if a database access error occurs; this method is called on a
	 *                closed result set or the result set concurrency is
	 *                <code>CONCUR_READ_ONLY</code>
	 * @exception SQLFeatureNotSupportedException
	 *                if the JDBC driver does not support this method
	 * @since JDK 1.2 (JDK 1.1.x developers: read the overview for JDBCResultSet)
	 */
	public void moveToInsertRow() throws MockSQLException, Exception {
		try {
			moveToInsertRow0();
		} catch (Exception ex) {
			throw ex;
		}

	}

	private void moveToInsertRow0() throws MockSQLException, Exception {
		startInsert();
	}

	/**
	 * <!-- start generic documentation --> Moves the cursor to the remembered
	 * cursor position, usually the current row. This method has no effect if the
	 * cursor is not on the insert row. <!-- end generic documentation -->
	 *
	 * <!-- start release-specific documentation -->
	 * <div class="ReleaseSpecificDocumentation">
	 * <h3>HSQLDB-Specific Information:</h3>
	 * <p>
	 *
	 * HSQLDB supports this feature.
	 * <p>
	 * </div> <!-- end release-specific documentation -->
	 * 
	 * @exception MockSQLException
	 *                if a database access error occurs, this method is called on a
	 *                closed result set or the result set concurrency is
	 *                <code>CONCUR_READ_ONLY</code>
	 * @exception SQLFeatureNotSupportedException
	 *                if the JDBC driver does not support this method
	 * @since JDK 1.2 (JDK 1.1.x developers: read the overview for JDBCResultSet)
	 */
	public void moveToCurrentRow() throws MockSQLException, Exception {
		try {
			this.moveToCurrentRow0();
		} catch (Exception ex) {
			throw ex;
		}

	}

	private void moveToCurrentRow0() throws MockSQLException, Exception {
		endInsert();
	}

	/**
	 * <!-- start generic documentation --> Retrieves the <code>Statement</code>
	 * object that produced this <code>ResultSet</code> object. If the result set
	 * was generated some other way, such as by a <code>DatabaseMetaData</code>
	 * method, this method may return <code>null</code>. <!-- end generic
	 * documentation -->
	 *
	 * @return the <code>Statment</code> object that produced this
	 *         <code>ResultSet</code> object or <code>null</code> if the result set
	 *         was produced some other way
	 * @exception MockSQLException
	 *                if a database access error occurs or this method is called on
	 *                a closed result set
	 * @since JDK 1.2 (JDK 1.1.x developers: read the overview for JDBCResultSet)
	 */
//	public MockStatement getStatement() throws MockSQLException, Exception {
//		try {
//			MockStatement rv = getStatement0();
//			return rv;
//		} catch (Exception ex) {
//			throw ex;
//		}
//
//	}

//	private MockStatement getStatement0() throws MockSQLException, Exception {
//		checkClosed();
//		return (MockStatement) statement;
//	}

	// -------------------------- JDBC 3.0 ----------------------------------------

	// #endif JAVA4

	// #endif JAVA4

	// #endif JAVA4

	// #endif JAVA4

	// #endif JAVA4

	// #endif JAVA4

	// #endif JAVA4

	// #endif JAVA4

	// #endif JAVA4

	// #endif JAVA4
	// ------------------------- JDBC 4.0 -----------------------------------

	// #endif JAVA6

	// #endif JAVA6

	// #endif JAVA6

	// #endif JAVA6

	/**
	 * Retrieves the holdability of this <code>ResultSet</code> object
	 * 
	 * @return either <code>ResultSet.HOLD_CURSORS_OVER_COMMIT</code> or
	 *         <code>ResultSet.CLOSE_CURSORS_AT_COMMIT</code>
	 * @throws MockSQLException
	 *             if a database access error occurs or this method is called on a
	 *             closed result set
	 * @since JDK 1.6, HSQLDB 2.0
	 */
//	public int getHoldability() throws MockSQLException, Exception {
//		try {
//			int rv = this.getHoldability0();
//			return rv;
//		} catch (Exception ex) {
//			throw ex;
//		}
//
//	}

//	private int getHoldability0() throws MockSQLException, Exception {
//		checkClosed();
//		return MockResultProperties.getJDBCHoldability(rsProperties);
//	}

	/**
	 * Retrieves whether this <code>ResultSet</code> object has been closed. A
	 * <code>ResultSet</code> is closed if the method close has been called on it,
	 * or if it is automatically closed.
	 *
	 * @return true if this <code>ResultSet</code> object is closed; false if it is
	 *         still open
	 * @throws MockSQLException
	 *             if a database access error occurs
	 * @since JDK 1.6, HSQLDB 2.0
	 */
//	public boolean isClosed() throws MockSQLException, Exception {
//		try {
//			boolean rv = isClosed0();
//			return rv;
//		} catch (Exception ex) {
//			throw ex;
//		}
//
//	}

//	private boolean isClosed0() throws MockSQLException, Exception {
//		return navigator == null;
//	}

	// #endif JAVA6

	// #endif JAVA6

	// #endif JAVA6

	// #endif JAVA6

	// #endif JAVA6

	// #endif JAVA6

	// #endif JAVA6

	// #endif JAVA6

	// #endif JAVA6

	// #endif JAVA6

	// #endif JAVA6

	// #endif JAVA6

	// #endif JAVA6

	// #endif JAVA6

	// #endif JAVA6

	// #endif JAVA6
	// --------------------------- Added: Mustang Build 86 -------------------------

	// #endif JAVA6

	// #endif JAVA6

	// #endif JAVA6

	// #endif JAVA6

	// #endif JAVA6

	// #endif JAVA6

	// #endif JAVA6

	// #endif JAVA6

	// #endif JAVA6

	// #endif JAVA6

	// #endif JAVA6

	// #endif JAVA6

	// --------------------- MockWrapper implementation -------------------

	// #endif JAVA6

	// #endif JAVA6
	// ------------------------ Internal Implementation
	// -----------------------------

	/** The internal representation. */
	private MockRowSetNavigator navigator;

	/** The internal representation. */
	private MockResultMetaData resultMetaData;

	/** How many columns does this ResultSet have? */
	private int columnCount;

	/** Did the last getXXX method encounter a null value? */
	private boolean wasNullValue;

	/** The ResultSetMetaData object for this ResultSet */
	private MockResultSetMetaData resultSetMetaData;

	/** MockJDBCConnection for this. */
	private MockJDBCConnection connection;

	/** Accelerates findColumn; Map<columnName, columnIndex> */
	private MockIntValueHashMap columnMap;

	/** The first warning in the chain. Null if there are no warnings. */
	private MockSQLWarning rootWarning;

	/** The underlying result. */
	private MockResult result;

	// -------------------------- Package Attributes ----------------------------

	/**
	 * The Statement that generated this result. Null if the result is from
	 * DatabaseMetaData
	 * <p>
	 */
	private MockJDBCStatementBase statement;
	private MockSessionInterface session;

	/**
	 * The scrollability / scroll sensitivity type of this result.
	 */
	private boolean isScrollable;

	/** The concurrency of this result. */
//	private boolean isReadOnly;

	/** The updatability of this result. */
	private boolean isUpdatable;

	/** The insertability of this result. */
	private boolean isInsertable;
	private int rsProperties;
//	private int fetchSize;

	/** Statement is closed when its result set is closed */
	private boolean autoClose;

	// ---------------------- Public Attributes --------------------------------
	// Support for JDBC 2 from JRE 1.1.x

	/** Copy of MockResultSet constant, for JDK 1.1 clients. */
	public static final int FETCH_FORWARD = 1000;

	/** Copy of MockResultSet constant, for JDK 1.1 clients. */
	public static final int FETCH_REVERSE = 1001;

	/** Copy of MockResultSet constant, for JDK 1.1 clients. */
	public static final int FETCH_UNKNOWN = 1002;

	/** Copy of MockResultSet constant, for JDK 1.1 clients. */
	public static final int TYPE_FORWARD_ONLY = 1003;

	/**
	 * Copy of MockResultSet constant, for JDK 1.1 clients.
	 * <p>
	 *
	 * (JDBC4 clarification:) scrollable but generally not sensitive to changes to
	 * the data that underlies the <code>ResultSet</code>.
	 */
	public static final int TYPE_SCROLL_INSENSITIVE = 1004;

	/**
	 * Copy of MockResultSet constant, for JDK 1.1 clients.
	 * <p>
	 *
	 * (JDBC4 clarification:) scrollable and generally sensitive to changes to the
	 * data that underlies the <code>ResultSet</code>.
	 */
	public static final int TYPE_SCROLL_SENSITIVE = 1005;

	/** Copy of MockResultSet constant, for JDK 1.1 clients. */
	public static final int CONCUR_READ_ONLY = 1007;

	/** Copy of MockResultSet constant, for JDK 1.1 clients. */
	public static final int CONCUR_UPDATABLE = 1008;

	/** Copy of MockResultSet constant, for JDK 1.1 clients. */
	public static final int HOLD_CURSORS_OVER_COMMIT = 1;

	/** Copy of MockResultSet constant, for JDK 1.1 clients. */
	public static final int CLOSE_CURSORS_AT_COMMIT = 2;

	// -------------------------- Private Methods -------------------------------

	/**
	 * Fetches the current row of the result set.
	 *
	 * @throws MockSQLException
	 *             when result set is closed; result set is empty; result set is
	 *             before first; result set is alfter last; no row data is
	 *             available.
	 * @return Object[]
	 */
	private Object[] getCurrent() throws MockSQLException, Exception {

		final MockRowSetNavigator lnavigator = this.navigator;

		if (lnavigator == null) {
			throw MockUtil.sqlException(MockErrorCode.X_24501);
		} else if (lnavigator.isEmpty()) {
			throw MockUtil.sqlException(MockErrorCode.X_24504, MockErrorCode.M_RS_EMPTY);
		} else if (lnavigator.isBeforeFirst()) {
			throw MockUtil.sqlException(MockErrorCode.X_24504, MockErrorCode.M_RS_BEFORE_FIRST);
		} else if (lnavigator.isAfterLast()) {
			throw MockUtil.sqlException(MockErrorCode.X_24504, MockErrorCode.M_RS_AFTER_LAST);
		}

		Object[] data = lnavigator.getCurrent();

		if (data == null) {
			throw MockUtil.sqlException(MockErrorCode.X_24501);
		}

		return data;
	}

	/**
	 * Internal closed state check.
	 *
	 * @throws MockSQLException
	 *             when this result set is closed
	 */
	private void checkClosed() throws MockSQLException, Exception {

		if (navigator == null) {
			throw MockUtil.sqlException(MockErrorCode.X_24501);
		}
	}

	/**
	 * Internal column index validity check.
	 *
	 * @param columnIndex
	 *            to check
	 * @throws MockSQLException
	 *             when this ResultSet has no such column
	 */
	private void checkColumn(int columnIndex) throws MockSQLException, Exception {

		if (navigator == null) {
			throw MockUtil.sqlException(MockErrorCode.X_24501);
		}

		if (columnIndex < 1 || columnIndex > columnCount) {
			throw MockUtil.sqlException(MockErrorCode.JDBC_COLUMN_NOT_FOUND, String.valueOf(columnIndex));
		}
	}

	/**
	 * Internal wasNull tracker.
	 *
	 * @param o
	 *            the Object to track
	 * @return boolean
	 */
	private boolean trackNull(Object o) {
		return (wasNullValue = (o == null));
	}

	/**
	 * Internal value converter.
	 * <p>
	 *
	 * All trivially successful getXXX methods eventually go through this method,
	 * converting if neccessary from the source type to the requested type.
	 * <p>
	 *
	 * Conversion to the JDBC representation, if different, is handled by the
	 * calling methods.
	 *
	 * @param columnIndex
	 *            of the column value for which to perform the conversion
	 * @param targetType
	 *            the com.example.types.Type object for targetType
	 * @return an Object of the requested targetType, representing the value of the
	 *         specified column
	 * @throws MockSQLException
	 *             when there is no rowData, the column index is invalid, or the
	 *             conversion cannot be performed
	 */
	private Object getColumnInType(int columnIndex, MockType targetType) throws MockSQLException, Exception {

		Object[] rowData = getCurrent();
		MockType sourceType;
		Object value;

		checkColumn(columnIndex);

		sourceType = resultMetaData.columnTypes[--columnIndex];
		value = rowData[columnIndex];

		if (trackNull(value)) {
			return null;
		}

		if (sourceType.typeCode != targetType.typeCode) {
			try {
				value = targetType.convertToTypeJDBC(session, value, sourceType);
			} catch (Exception e) {
				String stringValue = (value instanceof Number || value instanceof String) ? value.toString()
						: "instance of " + value.getClass().getName();
				String msg = "from SQL type " + sourceType.getNameString() + " to " + targetType.getJDBCClassName()
						+ ", value: " + stringValue;

				MockUtil.throwError(MockError.error(MockErrorCode.X_42561, msg));
			}
		}

		return value;
	}

	private void checkNotForwardOnly() throws MockSQLException, Exception {

		if (!isScrollable) {
			throw MockUtil.notSupported();
		}
	}

	// -------------------------- Updates --------------------------------------
	private MockJDBCPreparedStatement preparedStatement;
	private boolean isRowUpdated;
	private boolean isOnInsertRow;

	/**
	 * -2 after moveToInsertRow() -1 before any updateXXX() row number after any
	 * updateXXX() -1 after updateRow(), clearUpdate() or moveToCurrentRow();
	 */
	private int currentUpdateRowNumber;

	private void checkUpdatable() throws MockSQLException, Exception {

		checkClosed();

		if (!isUpdatable) {
			throw MockUtil.notUpdatableColumn();
		}
	}

	private void checkUpdatable(int columnIndex) throws MockSQLException, Exception {

		checkClosed();
		checkColumn(columnIndex);

		if (!isUpdatable) {
			throw MockUtil.notUpdatableColumn();
		}

		if (resultMetaData.colIndexes[--columnIndex] == -1) {
			throw MockUtil.notUpdatableColumn();
		}

		if (!resultMetaData.columns[columnIndex].isWriteable()) {
			throw MockUtil.notUpdatableColumn();
		}
	}

	private void startUpdate(int columnIndex) throws MockSQLException, Exception {

		checkUpdatable(columnIndex);

		if (currentUpdateRowNumber != navigator.getRowNumber()) {
			preparedStatement.clearParameters();
		}
		currentUpdateRowNumber = navigator.getRowNumber();
		isRowUpdated = true;
	}

	private void clearUpdates() throws MockSQLException, Exception {

		checkUpdatable();
		preparedStatement.clearParameters();

		isRowUpdated = false;
	}

	private void startInsert() throws MockSQLException, Exception {

		checkUpdatable();

		// check insertable
		isOnInsertRow = true;
	}

	private void endInsert() throws MockSQLException, Exception {

		checkUpdatable();
		preparedStatement.clearParameters();

		isOnInsertRow = false;
	}

	private void performUpdate() throws MockSQLException, Exception {

		preparedStatement.parameterValues[columnCount] = getCurrent()[columnCount];

		for (int i = 0; i < columnCount; i++) {
			boolean set = preparedStatement.parameterSet[i] || preparedStatement.parameterStream[i];

			preparedStatement.resultOut.metaData.columnTypes[i] = set ? preparedStatement.parameterTypes[i]
					: MockType.SQL_ALL_TYPES;
		}
		preparedStatement.resultOut.setActionType(MockResultConstants.UPDATE_CURSOR);
		preparedStatement.fetchResult();
		preparedStatement.clearParameters();

		rootWarning = preparedStatement.getWarnings();

		preparedStatement.clearWarnings();

		isRowUpdated = false;
	}

	private void performInsert() throws MockSQLException, Exception {

		checkUpdatable();

		for (int i = 0; i < columnCount; i++) {
			boolean set = preparedStatement.parameterSet[i] || preparedStatement.parameterStream[i];

			if (!set) {
				throw MockUtil.sqlException(MockErrorCode.X_24515);
			}
			preparedStatement.resultOut.metaData.columnTypes[i] = preparedStatement.parameterTypes[i];
		}
		preparedStatement.resultOut.setActionType(MockResultConstants.INSERT_CURSOR);
		preparedStatement.fetchResult();
		preparedStatement.clearParameters();

		rootWarning = preparedStatement.getWarnings();

		preparedStatement.clearWarnings();
	}

	private void performDelete() throws MockSQLException, Exception {

		checkUpdatable();

		preparedStatement.parameterValues[columnCount] = getCurrent()[columnCount];
		preparedStatement.resultOut.metaData.columnTypes[columnCount] = resultMetaData.columnTypes[columnCount];

		preparedStatement.resultOut.setActionType(MockResultConstants.DELETE_CURSOR);
		preparedStatement.fetchResult();
		preparedStatement.clearParameters();

		rootWarning = preparedStatement.getWarnings();

		preparedStatement.clearWarnings();
	}

	// ------------------------------ Contructors -------------------------------

	/**
	 * Constructs a new <code>JDBCResultSet</code> object using the specified
	 * navigator and <code>com.example.result.ResultMetaData</code>.
	 * <p>
	 *
	 * @param conn
	 *            MockJDBCConnection
	 * @param s
	 *            the statement
	 * @param r
	 *            the internal result form that the new <code>JDBCResultSet</code>
	 *            represents
	 * @param metaData
	 *            the connection properties
	 * @throws MockSQLException
	 *             when the supplied Result is of type com.example.Result.ERROR
	 */
	private JDBCResultSet(MockJDBCConnection conn, MockJDBCStatementBase s, MockResult r, MockResultMetaData metaData)
			throws MockSQLException, Exception {

		this.session = conn.sessionProxy;
		this.statement = s;
		this.result = r;
		this.connection = conn;
		rsProperties = r.rsProperties;
		navigator = r.getNavigator();
		resultMetaData = metaData;
		columnCount = resultMetaData.getColumnCount();
		isScrollable = MockResultProperties.isScrollable(rsProperties);

		if (MockResultProperties.isUpdatable(rsProperties)) {
			isUpdatable = true;
			isInsertable = true;

			for (int i = 0; i < metaData.colIndexes.length; i++) {
				if (metaData.colIndexes[i] < 0) {
					isInsertable = false;

					break;
				}
			}
			preparedStatement = new MockJDBCPreparedStatement(s.connection, result);
		}
	}

	private JDBCResultSet(MockJDBCConnection conn, MockResult r, MockResultMetaData metaData)
			throws MockSQLException, Exception {

		this.session = conn.sessionProxy;
		this.result = r;
		this.connection = conn;
		rsProperties = 0;
		navigator = r.getNavigator();
		resultMetaData = metaData;
		columnCount = resultMetaData.getColumnCount();
	}

	public final static String COLUMN_LABEL_0 = "columnLabel0";
	public final static String COLUMN_LABEL_1 = "columnLabel1";
	public final static String COLUMN_LABEL_2 = "columnLabel2";

	/**
	 * Creates a result set for a table named 'TABLE' with <code>columnsCount</code>
	 * integer columns named 'columnLabel0','columnLabel1'. The number of rows with
	 * the 0 value is the parameter <code>rows</code>.
	 * 
	 * @param columnsCount
	 * @param rows
	 * @return
	 * @throws MockSQLException
	 */
	public static JDBCResultSet buildNewMJDBCResultSet(int columnsCount, int rows) throws MockSQLException, Exception {

		if (columnsCount < 1)
			throw new IllegalArgumentException("column labels has to be greater than zero");

		if (columnsCount > 5)
			throw new IllegalArgumentException("Too many columns");

		if (rows < 0) {
			throw new IllegalArgumentException("Invalid row number");
		}

		String[] columnLabels = new String[columnsCount];
		for (int i = 0; i < columnsCount; i++) {
			columnLabels[i] = "columnLabel" + i;
		}

		int[][] table = new int[rows][];
		for (int i = 0; i < rows; i++) {
			table[i] = new int[columnsCount];
		}
		return buildNewJDBCResultSet0(columnLabels, table);
	}

	private JDBCResultSet(MockSessionInterface session, MockJDBCStatementBase s, MockResult r,
			MockResultMetaData metaData, MockJDBCConnection conn) throws MockSQLException, Exception {
		this.session = session;
		this.statement = s;
		this.result = r;
		this.connection = conn;
		rsProperties = r.rsProperties;
		navigator = r.getNavigator();
		resultMetaData = metaData;
		r.metaData = metaData;
		columnCount = resultMetaData.getColumnCount();
		isScrollable = MockResultProperties.isScrollable(rsProperties);
		if (MockResultProperties.isUpdatable(rsProperties)) {
			isUpdatable = true;
			isInsertable = true;
			for (int i = 0; i < metaData.colIndexes.length; i++) {
				if (metaData.colIndexes[i] < 0) {
					isInsertable = false;
					break;
				}
			}
			preparedStatement = new MockJDBCPreparedStatement(s.connection, result);
		}
	}

	private static JDBCResultSet buildNewJDBCResultSet0(String[] columnLabels, int[][] table)
			throws MockSQLException, Exception {
		if (columnLabels == null)
			throw new IllegalArgumentException("column label cannot be null");

		String query = "select ";
		for (int i = 0; i < columnLabels.length; i++) {
			if (i > 0)
				query += ",";
			query += columnLabels[i];
		}
		query += " from TABLE";
		MockRowSetNavigator navigator = new MockRowSetNavigator(columnLabels, table);
		MockResult r = new MockResult(query, navigator);
		r.rsProperties = 0;
		r.rsProperties = MockResultProperties.addScrollable(r.rsProperties, true);
		r.rsProperties = MockResultProperties.addUpdatable(r.rsProperties, true);

		int[] colIndexes = new int[columnLabels.length + 1];
		for (int i = 0; i < columnLabels.length; i++) {
			colIndexes[i] = i + 1;
		}
		colIndexes[columnLabels.length] = -1;
		MockResultMetaData metaData = new MockResultMetaData(columnLabels, colIndexes, columnLabels.length,
				columnLabels.length + 1);
		metaData.columnLabels = columnLabels;

		r.metaData = metaData;

		MockJDBCConnection conn = new MockJDBCConnection();
		MockSessionInterface sessionInterface = new MockSessionInterface();
		MockJDBCStatementBase stmt = new MockJDBCStatementBase();
		stmt.connection = sessionInterface;
		JDBCResultSet rs = new JDBCResultSet(sessionInterface, stmt, r, metaData, conn);
		return rs;
	}

	/**
	 * Creates a resultSet for a table with a single column (named
	 * <code>columnLabel0</code>). The integer values of this column are given in
	 * the values array.
	 * 
	 * @param values
	 * @return
	 * @throws MockSQLException
	 */
	public static JDBCResultSet buildNewJDBCResultSet(int... values) throws MockSQLException, Exception {
		final String columnLabel = COLUMN_LABEL_0;
		int[][] table = new int[values.length][];
		for (int i = 0; i < values.length; i++) {
			table[i] = new int[] { values[i] };
		}
		String[] label = new String[1];
		label[0] = columnLabel;
		return buildNewJDBCResultSet0(label, table);
	}

}
